<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reliable P2P Video Stream (Manual Signaling)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styling for a smooth, centered experience */
        .container {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background-color: #f0f4f8;
            font-family: 'Inter', sans-serif;
        }
        .video-box {
            border: 4px solid #4f46e5;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            background-color: #0d1117;
        }
        .video-label {
            position: absolute;
            top: 0.5rem;
            left: 0.5rem;
            background: rgba(0,0,0,0.5);
            color: white;
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            z-index: 10;
        }
        textarea {
            resize: none;
            font-size: 0.75rem;
            font-family: monospace;
        }
    </style>
</head>
<body>

<div class="container p-4">
    <div class="w-full max-w-5xl bg-white p-6 md:p-8 rounded-xl shadow-2xl">
        <h1 class="text-3xl font-extrabold text-gray-800 mb-2 text-center">
            P2P Video Stream (Manual Signaling)
        </h1>
        <p class="text-sm text-center text-red-600 mb-6 font-medium bg-red-50 p-3 rounded-lg">
            ⚠️ This is a serverless demo. The key is to **copy all the generated text (SDP) and paste it exactly** into the other device.
        </p>

        <!-- Video Streams -->
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
            <!-- Local Video (Streamer/Viewer) -->
            <div class="relative w-full aspect-video rounded-lg overflow-hidden bg-gray-700 flex items-center justify-center">
                <video id="localVideo" autoplay playsinline class="w-full h-full object-cover rounded-lg hidden video-box"></video>
                <span class="video-label bg-green-600">Your Local Camera</span>
                <div id="local-status" class="text-gray-300 p-8 text-center absolute">
                    Click 'Start Camera' to begin.
                </div>
            </div>

            <!-- Remote Video (The other device) -->
            <div class="relative w-full aspect-video rounded-lg overflow-hidden bg-gray-900 flex items-center justify-center">
                <video id="remoteVideo" autoplay playsinline class="w-full h-full object-cover rounded-lg hidden video-box"></video>
                <span class="video-label bg-red-600">Remote Stream</span>
                <div id="remote-status" class="text-gray-300 p-8 text-center absolute">
                    Waiting for remote video feed...
                </div>
            </div>
        </div>

        <!-- Controls and Signaling -->
        <div class="p-4 bg-gray-100 rounded-lg shadow-inner">
            <div class="grid grid-cols-1 gap-4">
                <!-- Step 1: Start Camera -->
                <div class="flex flex-col sm:flex-row items-center gap-4 border-b pb-4 mb-4">
                    <div class="text-lg font-bold text-gray-700 w-12 h-12 flex items-center justify-center rounded-full bg-indigo-200">1</div>
                    <button id="startCameraButton" class="flex-grow py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 transition duration-300 disabled:opacity-50">
                        Start Camera & Prepare Connection
                    </button>
                    <p id="status" class="text-sm text-gray-600 w-full sm:w-auto text-center">Idle</p>
                </div>

                <!-- Step 2: Signaling -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <!-- Column A: Create Offer/Answer -->
                    <div>
                        <h3 class="text-lg font-semibold mb-2 text-gray-800">Your Output (Copy this)</h3>
                        <textarea id="sdpOutput" placeholder="The Offer or Answer will appear here. Copy this text (it is copied automatically if allowed) and paste it into the 'Remote Input' box on the other device." rows="8" class="w-full p-2 border border-gray-300 rounded-lg bg-white"></textarea>
                        <button id="createOfferButton" disabled class="w-full mt-2 py-2 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 transition duration-300 disabled:opacity-50">
                            Create Offer (Streamer First Step)
                        </button>
                        <button id="createAnswerButton" disabled class="w-full mt-2 py-2 bg-yellow-600 text-white font-semibold rounded-lg hover:bg-yellow-700 transition duration-300 disabled:opacity-50">
                            Create Answer (Viewer Second Step)
                        </button>
                    </div>

                    <!-- Column B: Remote Input -->
                    <div>
                        <h3 class="text-lg font-semibold mb-2 text-gray-800">Remote Input (Paste here)</h3>
                        <textarea id="sdpInput" placeholder="Paste the Offer or Answer text from the other device here." rows="8" class="w-full p-2 border border-gray-300 rounded-lg bg-white"></textarea>
                        <button id="setRemoteButton" disabled class="w-full mt-2 py-2 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700 transition duration-300 disabled:opacity-50">
                            Set Remote Offer/Answer & Connect
                        </button>
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>

<script>
    // --- Global Variables ---
    let peerConnection;
    let localStream;
    const configuration = { 
        // Public STUN servers for NAT traversal (necessary for P2P connection)
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ] 
    };

    // --- DOM Elements ---
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const startCameraButton = document.getElementById('startCameraButton');
    const createOfferButton = document.getElementById('createOfferButton');
    const createAnswerButton = document.getElementById('createAnswerButton');
    const setRemoteButton = document.getElementById('setRemoteButton');
    const sdpOutput = document.getElementById('sdpOutput');
    const sdpInput = document.getElementById('sdpInput');
    const statusElement = document.getElementById('status');

    // --- Utility Functions ---
    function updateStatus(message, isError = false) {
        statusElement.textContent = message;
        statusElement.className = isError 
            ? 'text-sm text-red-600 font-semibold' 
            : 'text-sm text-indigo-600 font-semibold';
    }
    
    // Helper function to wait for ICE gathering to complete before retrieving the SDP
    function waitForIceGatheringComplete() {
        return new Promise(resolve => {
            if (peerConnection.iceGatheringState === 'complete') {
                resolve();
            } else {
                const checkState = () => {
                    if (peerConnection.iceGatheringState === 'complete') {
                        peerConnection.removeEventListener('icegatheringstatechange', checkState);
                        // No need to remove icecandidate listener as we haven't added one here
                        resolve();
                    }
                };
                peerConnection.addEventListener('icegatheringstatechange', checkState);
                
                // Fallback timeout in case ICE gathering stalls (5 seconds)
                setTimeout(() => {
                    peerConnection.removeEventListener('icegatheringstatechange', checkState);
                    resolve();
                }, 5000); 
            }
        });
    }

    // --- WebRTC Core Functions ---

    // 1. Get Camera Stream and Initialize PC
    async function startCameraAndInitialize() {
        if (localStream) return; // Prevent double initialization
        
        try {
            updateStatus('Requesting camera access...');
            
            // Request access to video and audio
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = localStream;
            localVideo.classList.remove('hidden');
            document.getElementById('local-status').style.display = 'none';
            localVideo.muted = true; 

            // Initialize Peer Connection
            peerConnection = new RTCPeerConnection(configuration);

            // Add local tracks to the peer connection
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Handle remote tracks (the incoming stream)
            peerConnection.ontrack = (event) => {
                console.log("Received remote track.");
                if (remoteVideo.srcObject !== event.streams[0]) {
                    remoteVideo.srcObject = event.streams[0];
                    remoteVideo.classList.remove('hidden');
                    document.getElementById('remote-status').style.display = 'none';
                    updateStatus('Connection established! Streaming live.', false);
                }
            };
            
            // Log ICE candidates, but we rely on waitForIceGatheringComplete for the final SDP
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`ICE candidate gathered: ${event.candidate.type}`);
                }
            };
            
            updateStatus('Camera active. Ready to create/receive SDP.', false);
            startCameraButton.disabled = true;
            createOfferButton.disabled = false;
            setRemoteButton.disabled = false;
            
        } catch (e) {
            console.error('Initialization Error:', e);
            updateStatus('Error: Camera access denied or device not found.', true);
        }
    }
    
    // 2. Create SDP Offer (Streamer side)
    async function createOffer() {
        if (!peerConnection) return;
        updateStatus('Creating Offer...', false);
        sdpOutput.value = '';
        createOfferButton.disabled = true;
        
        try {
            const offer = await peerConnection.createOffer();
            await peerConnection.setLocalDescription(offer);
            
            // RELIABILITY FIX: Wait for ICE gathering to complete
            updateStatus('Waiting for network information (ICE) to gather... Please wait.', false);
            await waitForIceGatheringComplete();
            
            sdpOutput.value = JSON.stringify(peerConnection.localDescription);
            
            // Attempt to copy to clipboard
            try {
                await navigator.clipboard.writeText(sdpOutput.value);
                updateStatus('Offer created and copied to clipboard! Paste this text into the other device.', false);
            } catch (e) {
                updateStatus('Offer created. Copy the text above and paste it into the other device.', false);
            }
            
            createAnswerButton.disabled = true; // Streamer's next step is setting the remote answer
            createOfferButton.disabled = true;

        } catch (e) {
            console.error('Error creating offer:', e);
            updateStatus('Error creating Offer.', true);
        }
    }
    
    // 3. Set Remote Description (Both sides)
    async function setRemoteDescription() {
        if (!peerConnection) {
            updateStatus('Please start the camera first.', true);
            return;
        }

        const remoteSdpText = sdpInput.value.trim();
        if (!remoteSdpText) {
            updateStatus('Paste the remote Offer/Answer into the input box first.', true);
            return;
        }

        try {
            const remoteSdp = new RTCSessionDescription(JSON.parse(remoteSdpText));
            updateStatus(`Setting remote ${remoteSdp.type}...`);

            await peerConnection.setRemoteDescription(remoteSdp);
            
            if (remoteSdp.type === 'offer') {
                // Viewer flow: If we received an Offer, we need to generate an Answer next
                if (!localStream) {
                     // Viewer needs to grab local stream if they haven't already
                     await startCameraAndInitialize();
                }
                updateStatus('Remote Offer set. Now, click "Create Answer" to finalize.', false);
                createAnswerButton.disabled = false;
                createOfferButton.disabled = true; 
            } else if (remoteSdp.type === 'answer') {
                // Streamer flow: If we received an Answer, the connection process is complete
                updateStatus('Remote Answer set. Connection attempt initiating...', false);
                createAnswerButton.disabled = true; 
                createOfferButton.disabled = true;
            }
            
            setRemoteButton.disabled = true; // Disable until a new SDP is needed

        } catch (e) {
            console.error('Error setting remote description:', e);
            updateStatus('Error setting remote SDP. Check format and try again.', true);
        }
    }

    // 4. Create SDP Answer (Viewer side)
    async function createAnswer() {
        if (!peerConnection) return;
        updateStatus('Creating Answer...', false);
        sdpOutput.value = '';
        createAnswerButton.disabled = true; 

        try {
            const answer = await peerConnection.createAnswer();
            await peerConnection.setLocalDescription(answer);

            // RELIABILITY FIX: Wait for ICE gathering to complete
            updateStatus('Waiting for network information (ICE) to gather... Please wait.', false);
            await waitForIceGatheringComplete();
            
            sdpOutput.value = JSON.stringify(peerConnection.localDescription);

            // Attempt to copy to clipboard
            try {
                await navigator.clipboard.writeText(sdpOutput.value);
                updateStatus('Answer created and copied to clipboard! Paste this text back into the first device.', false);
            } catch (e) {
                updateStatus('Answer created. Copy the text above and paste it back into the first device.', false);
            }
            
            createAnswerButton.disabled = true;
            createOfferButton.disabled = true;
        } catch (e) {
            console.error('Error creating answer:', e);
            updateStatus('Error creating Answer.', true);
        }
    }


    // --- Event Listeners and Initial Load ---
    startCameraButton.addEventListener('click', startCameraAndInitialize);
    createOfferButton.addEventListener('click', createOffer);
    createAnswerButton.addEventListener('click', createAnswer);
    setRemoteButton.addEventListener('click', setRemoteDescription);

    // Cleanup when browser closes
    window.onbeforeunload = () => {
        if (localStream) {
            localStream.getTracks().forEach(track => track.stop());
        }
        if (peerConnection) {
            peerConnection.close();
        }
    };
    
</script>

</body>
</html>
